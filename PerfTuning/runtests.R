################################################################ 
## Title: Main test driver for performance tuning.
## Description:: Main R file to run tests to compare how various
##              performance tuning tips can affect performance
##              of running rx analytic functions in SQL compute 
##              context.
## Author: Microsoft 
################################################################ 
library("RODBC") # Install this package if missing on the machine before running this script

source("serialization.R")

####################################################################################################
# Database information
####################################################################################################
options(sqlConnString = "Driver=SQL Server;Server=.; Database=PerfTuning;Trusted_Connection=TRUE;")
sqlConnString <- getOption("sqlConnString") # required option

####################################################################################################
# Directory where the scripts and data are. Update this before running test.
####################################################################################################
options(dir = "F:/git/SQL-Server-R-Services-Samples/PerfTuning")
dir <- getOption("dir")

if (!file.exists(dir))
{
  stop( "dir does not exist");
}

dataDir <- file.path(dir, "Data")
if (!file.exists(dataDir))
{
  stop( "dataDir does not exist");
}


####################################################################################################
# Helper function to return sql compute context.
####################################################################################################
getSqlComputeContext <- function(numTasks, sqlConnString) {
  sqlShareDir <- paste("c:\\temp\\", Sys.getenv("USERNAME"), sep="")
  dir.create(sqlShareDir, recursive = TRUE, showWarnings = FALSE) 
  sqlWait <- TRUE 
  sqlConsoleOutput <- TRUE 
  RxInSqlServer(connectionString = sqlConnString, shareDir = sqlShareDir, 
                wait = sqlWait, consoleOutput = sqlConsoleOutput, numTasks = numTasks) 
}

####################################################################################################
# Helper function to process file generated by rx analytic functions when using reportProgress parameter.
####################################################################################################
processOutput = function(file.path) {
  ff = file(file.path)
  lines = readLines(con=ff)
  close(ff)
  
  perfStrs = c("Overall compute", "Total read", "Total transform")
  
  res = NULL
  
  # There could be multiple iterations - rxGlm for example. In that case, there are multiple
  # lines of the same pattern.
  for(ss in perfStrs) {
    mm = grep(ss, lines)
    if(NROW(mm) > 0) {
      description = ""
      total.time = 0
      for(ii in mm) {
        # Skip debugger lines that are not real output.
        if (NROW(grep("Called from:", lines[ii])) > 0 || 
            NROW(grep("debug at", lines[ii])) > 0) {
          next
        }
        both.strs = strsplit(lines[ii], ": ")[[1]]
        total.time = total.time + as.numeric(strsplit(both.strs[2], " ")[[1]][1])
        description = both.strs[1]
      }
      res = rbind(res, data.frame(metric=description, time=total.time))
    }
  }
  
  # Replace "Total read time for XX reads" with simply "Total read time"
  aa = as.character(res[,1])
  aa[grep("Total read", aa)] = "Total read time"
  aa[grep("Overall compute", aa)] = "Overall compute time"
  res[,1] = aa
  
  return(res)
}

####################################################################################################
# Helper function to processing timings data.
####################################################################################################
processTimings = function(testResult) {
  # drop the first run and average the results. 
  # Columns are: metric time1 time2 ...timeN. We are dropping time1 column.
  origRes <- testResult$output
  avgTime <- testResult$avgTime
  res <- origRes[,c(1,3:NCOL(origRes))]
  res <- cbind(res[,1,drop=F], rowMeans(res[,-1,drop=F]))
  colnames(res) <- c("metric","time")
  
  # add the total time row
  res <- rbind(data.frame(metric="Total time",time=as.numeric(avgTime)), res)
  
  # Add the transition time. Currently it's total time minus analytic time.
  tt <- grep("Overall compute", res[,1])
  if(NROW(tt) != 1) {
    stop("Wrong number of matches [for Overall compute]!")
  }
  transition.time <- avgTime - res[tt[1],2]
  res <- rbind(res, data.frame(metric="Transition time",time=transition.time))
  
  # Add the total processing time. Currently: Analytic Time minus IO Time
  yy <- grep("Total read", res[,1])
  if(NROW(yy) != 1) {
    stop("Wrong number of matches [for Total read]!")
  }
  nonio.time <- res[tt[1],2] - res[yy[1],2]
  res <- rbind(res, data.frame(metric="Total non IO time",time=nonio.time))
  
  # add pct column
  pct <- round(res[,2]/res[1,2]*100,2)
  res <- cbind(res, pct)
  
  return(res)
}

####################################################################################################
# Simple helper to get current time in readable format
####################################################################################################
getNowTimeString <- function() {
  format(Sys.time(), "%m/%d/%Y %I:%M:%S %p")
}

####################################################################################################
# Simple helper to get dataframe from RxSqlServerData for use with lm, glm functions
####################################################################################################
getDataFrameFromDataSource <- function(dataSource, tableName) {
  data <- NULL
  if (inherits(dataSource, "RxSqlServerData")) {
    attr = attributes(dataSource)
    if (!("sqlQuery" %in% names(attr))) {
      return(NULL)
    }
    query = attr$sqlQuery
    
    sqlConnString <- getOption("sqlConnString") 
    if (!is.null(attr$connectionString) && !is.na(attr$connectionString)) {
      sqlConnString = attr$connectionString
    }
    ch <- odbcDriverConnect(sqlConnString)
    on.exit(odbcClose(ch))
    data <- sqlQuery(ch, query)
  }
  if (!is.null(data)) {
    cols <- names(data)
    if ("DayOfWeek" %in% cols) {
      if (tableName == "airline") {
        levels <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")
      }
      else {
        levels = as.character(1:7)
      }
      data$DayOfWeek <- factor(data$DayOfWeek, levels)
    }
  }
  return(data)
}

cleanupModel = function(m) {
  m$family$variance = c()
  m$family$dev.resids = c()
  m$family$aic = c()
  m$family$validmu = c()
  m$family$simulate = c()
  m$y = c()
  m$model = c()
  m$residuals = c()
  m$fitted.values = c()
  m$effects = c()
  m$qr$qr = c()  
  m$linear.predictors = c()
  m$weights = c()
  m$prior.weights = c()
  m$data = c()
  attr(m$terms,".Environment") = c()
  attr(m$formula,".Environment") = c()
  m
}

####################################################################################################
# Driver function to run one single test with given parameters.
# Returns output timings, average time, and the analytic function output (such as model generated).
####################################################################################################
runTest = function(resultDir, analytic="rxLinMod", formula, dataSource, transformFunc, transformVars, runs=3, cube=F, maxDepth=1, ...)
{
  # The analytic has to be passed as a character string
  if(!is.character(analytic)) {
    stop("Analytic must be a character string ['rxLinMod' for rxLinMod]!")
  }
  
  suppressWarnings(dir.create(resultDir)) # Make Sure timestamp Folder exists
  
  N = runs
  set.seed(1)
  
  runId = 1
  
  total.times = rep(0, N+1)
  max.time = -1
  combined.output <- NULL
  analyticsResult <- "undefined"
  for (i in 0:N) {
    invisible(gc())
    
    # The output file
    baseName <- paste(".", analytic, ".", format(Sys.time(), "%Y%m%d-%H%M%OS6"), sep = "")
    output.file = file.path(resultDir, paste("output", baseName, ".txt", sep=""))
    analyticsResult <- "undefined"
    
    # Redirect the output
    sink(output.file)
    
    # Run the test
    tryCatch( 
      {
        if (analytic == "rxLinMod") {
          time = system.time(
            analyticsResult <- rxLinMod(
              formula = formula,
              transformFunc = transformFunc,
              transformVars = transformVars,
              data = dataSource,
              cube = cube,
              reportProgress = 3
            )
          )[3]          
        } else if (analytic == "rxGlm") {
          time = system.time(
            analyticsResult <- rxGlm(
              formula = formula,
              transformFunc = transformFunc,
              transformVars = transformVars,
              data = dataSource,
              reportProgress = 3
            )
          )[3]          
        } else if (analytic == "rxLogit") {
          time = system.time(
            analyticsResult <- rxLogit(
              formula = formula,
              transformFunc = transformFunc,
              transformVars = transformVars,
              data = dataSource,
              reportProgress = 3
            )
          )[3]            
        } else if (analytic == "rxDTree") {
          time = system.time(
            analyticsResult <- rxDTree(
              formula = formula,
              transformFunc = transformFunc,
              transformVars = transformVars,
              data = dataSource,
              maxDepth = maxDepth,
              reportProgress = 3
            )
          )[3]            
        } else if (analytic == "lm" || analytic == "glm") {
          # lm tests use only airlineWithIndex table only. 
          ioTime = system.time(dataFrame <- getDataFrameFromDataSource(dataSource, "airlineWithIndex"))[3] 
          if (!is.null(dataFrame)) {
            if (analytic == "Glm") {
              computeTime = system.time(
                output <- glm(formula = formula, data=dataFrame))[3]
            } else {
              computeTime = system.time(
                output <- lm(formula = formula, data=dataFrame))[3]
            }
          } else {
            warning(paste("dataFrame produced null for ", analytic, sep=""))
            computeTime <- 0
          }
          
          ioTime <- as.numeric(ioTime)
          computeTime <- as.numeric(computeTime)
          time <- ioTime + computeTime
          # processOutput call below is strict. We need <desc>: <time> with one space after :
          cat("Overall compute time:", time, "\n")
          cat("Total read:", ioTime, "\n")
          cat("Total loop time:", computeTime, "\n")
          cat("Total transform: 0\n")
          cat("Total process data time:", time, "\n")
          analyticsResult <- output        
        } else {
          cat("Analytic function supplied is not implemented.\n")
          return(NULL)
        }
      },
      
      finally = sink()
    );
    # Process the output
    oo = processOutput(output.file)
    combined.output = if (is.null(combined.output))
      oo
    else
      cbind(combined.output, oo[,2])
    
    total.times[i + 1] = time
    if (i > 0 && max.time < time[[1]]) {
      max.time <- time[[1]] # keep track of max of all times except the very first one.
    }
    if (printEachTestRuntime) {
      cat("      run ", runId, " took ", time, " seconds", "\n")
    }
    runId = runId + 1
  }

  # Don't account for the first run 
  averageTime = (sum(tail(total.times,-1)) - max.time)/(N-1)
  
  n.col = NCOL(combined.output)
  colnames(combined.output)[2:n.col] = paste("time",1:(n.col-1),sep="")
  
  return(list(output=combined.output,avgTime=averageTime,analyticsResult=analyticsResult))
}

####################################################################################################
# Simple helper to get compute column info from xdf file to deal with factors for sql data source.
####################################################################################################
getColInfoForSqlDataSource <- function(rxXdfData, columns, treatFactorColAsInt = FALSE)
{
  oldComputeContext <- rxGetComputeContext()
  on.exit(rxSetComputeContext(oldComputeContext))
  
  rxSetComputeContext ("local") # Work around for rxGetVarInfo not returning factor level when cc is not local.
  rxXdfDataInfo <- rxGetVarInfo(rxXdfData)
  
  result <- list()
  for(col in columns)
  {
    factorLevels <- rxXdfDataInfo[[col]]$levels
    if (treatFactorColAsInt)
    {
      result[[col]] = list(type="factor", levels = as.character(c(1:length(factorLevels))), newLevels = factorLevels)
    }
    else
    {
      result[[col]] = list(type="factor", levels = factorLevels)
    }
  }
  result
}


####################################################################################################
# Main driver function to run a series of tests and produce resutls in given output folder.
# numTasks controls the number of processes requested for the SQL compute context.
# rowsPerRead controls the number of rows to read per batch processing by the analytic function.
####################################################################################################
runTests = function(testsToRun, outputFolder, numTasks, rowsPerRead=500000L)
{
  oldComputeContext <- rxGetComputeContext()
  on.exit(rxSetComputeContext(oldComputeContext))

  resultDir <- file.path(resultsFolderDir, outputFolder)
  
  sqlcc <- getSqlComputeContext(numTasks, sqlConnString)
  rxSetComputeContext(sqlcc)
  cat ("Running tests with SQL compute context. numTasks = ", numTasks, " rowsPerRead = ", rowsPerRead, "\n")

  if ("FactorCol" %in% testsToRun) {
    colInfo <- getColInfoForSqlDataSource(airlineXdf, c("DayOfWeek"), FALSE)
    formula <- ArrDelay ~ CRSDepTime + DayOfWeek
    airlineTable <- RxSqlServerData(table="airline", connectionString = sqlConnString, colInfo = colInfo)
    cat("\nRunning FactorCol Test. Using airline table.", "\n")
    testResult <- runTest(resultDir, "rxLinMod", formula = formula, dataSource = airlineTable, transformFunc = NULL, transformVars = NULL, runs=5)
    cat("Average Time: ", testResult$avgTime, "\n")
    times <- processTimings(testResult)
    if (printTimeSplits) {
      print(times)
    }
  }
  
  if ("IntCol" %in% testsToRun) {
    formula <- ArrDelay ~ CRSDepTime + DayOfWeek
    airlineWithIntCol <- RxSqlServerData(table="airlineWithIntCol", connectionString = sqlConnString)
    cat("\nRunning IntCol Test. Using airlineWithIntCol table.", "\n")
    testResult <- runTest(resultDir, "rxLinMod", formula = formula, dataSource = airlineWithIntCol, transformFunc = NULL, transformVars = NULL, runs=5)
    cat("Average Time: ", testResult$avgTime, "\n")
    times <- processTimings(testResult)
    if (printTimeSplits) {
      print(times)
    }
  }
  
  if ("NoCompression" %in% testsToRun) {
    formula = Late ~ CRSDepTime + DayOfWeek + CRSDepHour:DayOfWeek
    airlineWithIndex <- RxSqlServerData(sqlQuery="select [ArrDelay],[CRSDepTime],[DayOfWeek] FROM airlineWithIndex", rowsPerRead = rowsPerRead, 
                                        connectionString = sqlConnString)
    cat("\nRunning NoCompression Test. Using airlineWithIndex table.", "\n")
    testResult <- runTest(resultDir, "rxLinMod", formula = formula, dataSource = airlineWithIndex, transformFunc = function(data) {
      data$Late = data$ArrDelay > 15
      data$CRSDepHour = as.integer(trunc(data$CRSDepTime))
      return(data)
    }, transformVars = c("ArrDelay","CRSDepTime"), runs=5)
    cat("Average Time: ", testResult$avgTime, "\n")
    times <- processTimings(testResult)
    if (printTimeSplits) {
      print(times)
    }
  }
  
  if ("PageCompression" %in% testsToRun) {
    formula = Late ~ CRSDepTime + DayOfWeek + CRSDepHour:DayOfWeek
    airlineWithPageComp <- RxSqlServerData(sqlQuery="select [ArrDelay],[CRSDepTime],[DayOfWeek] FROM airlineWithPageComp", rowsPerRead = rowsPerRead, connectionString = sqlConnString)
    cat("\nRunning PageCompression Test. Using airlineWithPageComp table.", "\n")
    testResult <- runTest(resultDir, "rxLinMod", formula = formula, dataSource = airlineWithPageComp, transformFunc = function(data) {
      data$Late = data$ArrDelay > 15
      data$CRSDepHour = as.integer(trunc(data$CRSDepTime))
      return(data)
    }, transformVars = c("ArrDelay","CRSDepTime"), runs=5)
    cat("Average Time: ", testResult$avgTime, "\n")
    times <- processTimings(testResult)
    if (printTimeSplits) {
      print(times)
    }
  }
  
  if ("RowCompression" %in% testsToRun) {
    formula = Late ~ CRSDepTime + DayOfWeek + CRSDepHour:DayOfWeek
    airlineWithRowComp <- RxSqlServerData(sqlQuery="select [ArrDelay],[CRSDepTime],[DayOfWeek] FROM airlineWithRowComp", rowsPerRead = rowsPerRead, connectionString = sqlConnString)
    cat("\nRunning RowCompression Test. Using airlineWithRowComp table.", "\n")
    testResult <- runTest(resultDir, "rxLinMod", formula = formula, dataSource = airlineWithRowComp, transformFunc = function(data) {
      data$Late = data$ArrDelay > 15
      data$CRSDepHour = as.integer(trunc(data$CRSDepTime))
      return(data)
    }, transformVars = c("ArrDelay","CRSDepTime"), runs=5)
    cat("Average Time: ", testResult$avgTime, "\n")
    times <- processTimings(testResult)
    if (printTimeSplits) {
      print(times)
    }
  }
  
  if ("WithTransformation" %in% testsToRun) {
    formula = Late ~ CRSDepTime + DayOfWeek + CRSDepHour:DayOfWeek
    airlineWithIndex <- RxSqlServerData(sqlQuery="select [ArrDelay],[CRSDepTime],[DayOfWeek] FROM airlineWithIndex", connectionString = sqlConnString)
    cat("\nRunning WithTransformation Test. Using airlineWithIndex table.", "\n")
    testResult <- runTest(resultDir, "rxLinMod", formula = formula, dataSource = airlineWithIndex, transformFunc = function(data) {
      data$Late = data$ArrDelay > 15
      data$CRSDepHour = as.integer(trunc(data$CRSDepTime))
      return(data)
    }, transformVars = c("ArrDelay","CRSDepTime"), runs=5)
    cat("Average Time: ", testResult$avgTime, "\n")
    times <- processTimings(testResult)
    if (printTimeSplits) {
      print(times)
    }
  }
  
  if ("WithoutTransformation" %in% testsToRun) {
    # The query used in this test depends on the columns Late and CRSDepHour to exist in the table.
    formula = Late ~ CRSDepTime + DayOfWeek + CRSDepHour:DayOfWeek
    airlineWithIndex <- RxSqlServerData(sqlQuery="select [ArrDelay],[CRSDepTime],[DayOfWeek], [Late], [CRSDepHour] FROM airlineWithIndex", connectionString = sqlConnString)
    cat("\nRunning WithoutTransformation Test. Using airlineWithIndex table.", "\n")
    testResult <- runTest(resultDir, "rxLinMod", formula = formula, dataSource = airlineWithIndex, transformFunc = NULL, transformVars = NULL, runs=5)
    cat("Average Time: ", testResult$avgTime, "\n")
    times <- processTimings(testResult)
    if (printTimeSplits) {
      print(times)
    }
  }
  
  if ("RowStore" %in% testsToRun) {
    formula = Late ~ CRSDepTime + DayOfWeek + CRSDepHour:DayOfWeek
    airlineWithIndex <- RxSqlServerData(sqlQuery="select [ArrDelay],[CRSDepTime],[DayOfWeek], [Late], [CRSDepHour] FROM airlineWithIndex", connectionString = sqlConnString)
    cat("\nRunning RowStore Test. No transformation. Using airlineWithIndex table.", "\n")
    testResult <- runTest(resultDir, "rxLinMod", formula = formula, dataSource = airlineWithIndex, transformFunc = NULL, transformVars = NULL, runs=5)
    cat("Average Time: ", testResult$avgTime, "\n")
    times <- processTimings(testResult)
    if (printTimeSplits) {
      print(times)
    }
  }

  if ("ColStore" %in% testsToRun) {
    formula = Late ~ CRSDepTime + DayOfWeek + CRSDepHour:DayOfWeek
    airlineColumnar <- RxSqlServerData(sqlQuery="select [ArrDelay],[CRSDepTime],[DayOfWeek], [Late], [CRSDepHour] FROM airlineColumnar", connectionString = sqlConnString)
    cat("\nRunning ColStore Test. No transformation. Using airlineColumnar table.", "\n")
    testResult <- runTest(resultDir, "rxLinMod", formula = formula, dataSource = airlineColumnar, transformFunc = NULL, transformVars = NULL, runs=5)
    cat("Average Time: ", testResult$avgTime, "\n")
    times <- processTimings(testResult)
    if (printTimeSplits) {
      print(times)
    }
  }
  if ("CubeArgEffect" %in% testsToRun) {
    formula <- ArrDelay ~ Origin:DayOfWeek + Month + DayofMonth + CRSDepTime
    colInfo <- getColInfoForSqlDataSource(airlineXdf, c("Origin", "DayOfWeek"))
    airline <- RxSqlServerData(sqlQuery="select [ArrDelay],[Origin],[DayOfWeek], [Month],[DayofMonth],[CRSDepTime] FROM airline", 
                                        colInfo = colInfo,
                                        connectionString = sqlConnString)
    cat("\nRunning CubeArgEffect Test with Cube = F. Using airline table.", "\n")
    testResult1 <- runTest(resultDir, "rxLinMod", formula = formula, dataSource = airline, transformFunc = NULL, transformVars = NULL, runs=5)
    cat("Average Time: ", testResult1$avgTime, "\n")
    times <- processTimings(testResult1)
    if (printTimeSplits) {
      print(times)
    }
    cat("\nRunning CubeArgEffect Test with Cube = T. Using airline table.", "\n")
    testResult2 <- runTest(resultDir, "rxLinMod", formula = formula, dataSource = airline, transformFunc = NULL, transformVars = NULL, runs=5, cube=T)
    cat("Average Time: ", testResult2$avgTime, "\n")
    times <- processTimings(testResult2)
    if (printTimeSplits) {
      print(times)
    }
    # Predict with both models.
    savedComputeContext <- rxGetComputeContext()
    rxSetComputeContext ("local")
    df <- data.frame(DayOfWeek=factor("Thur",colInfo$DayOfWeek$levels), 
                     CRSDepTime=9, 
                     Origin=factor("JFK", colInfo$Origin$levels),
                     Month=10, 
                     DayofMonth=1)
    pred1 <- rxPredict(testResult1$analyticsResult, df)
    pred2 <- rxPredict(testResult2$analyticsResult, df)
    cat("Predict using model from Cube=F\n")
    print(pred1)
    cat("Predict using model from Cube=T\n")
    print(pred2)
    rxSetComputeContext(savedComputeContext)
  }
  
  if ("SaveModel" %in% testsToRun) {
    formula = ArrDelay ~ Origin:DayOfWeek + Month + DayofMonth + CRSDepTime
    airline <- RxSqlServerData(sqlQuery="select [ArrDelay],[Origin],[DayOfWeek], [Month],[DayofMonth],[CRSDepTime] FROM airline", 
                               colInfo = getColInfoForSqlDataSource(airlineXdf, c("Origin", "DayOfWeek")),
                               connectionString = sqlConnString)
    cat("\nRunning SaveModel Test. Using airline table.", "\n")
    testResult <- runTest(resultDir, "rxLinMod", formula = formula, dataSource = airline, transformFunc = NULL, transformVars = NULL, runs=5, cube=T)
    cat("Average Time: ", testResult$avgTime, "\n")
    times <- processTimings(testResult)
    if (printTimeSplits) {
      print(times)
    }
    odbcDS <- RxOdbcData(table = "rdata", connectionString = sqlConnString, useFastRead=TRUE)
    rxOpen(odbcDS, "w")
    rxExecuteSQLDDL(odbcDS, sSQLString = paste("delete from [rdata] where [key] = 'linmod.model.1'", sep=""))
    rxClose(odbcDS)
    time = system.time({
      dbSaveRDS(sqlConnString, "linmod.model.1", testResult$analyticsResult)
    })[3]
    cat ("Time to save model = ", time, "\n")
  }

  if ("LoadModelAndPredict" %in% testsToRun) {
    savedComputeContext <- rxGetComputeContext()
    rxSetComputeContext ("local")
    cat("\nRunning LoadModelAndPredict Test. One row prediction. Using airline table and local compute context.", "\n")
    time = system.time({
      mm <- dbReadRDS(sqlConnString, "linmod.model.1")
      # Prepare the data for single row scoring
      colInfo <- getColInfoForSqlDataSource(airlineXdf, c("Origin", "DayOfWeek"))
      df <- data.frame(DayOfWeek=factor("Thur",colInfo$DayOfWeek$levels), 
                       CRSDepTime=9, 
                       Origin=factor("JFK", colInfo$Origin$levels),
                       Month=10, 
                       DayofMonth=1)
      pred <- rxPredict(mm, df)
      cat ("prediction: ArrayDelay = ", pred[1,], "\n")
      rxSetComputeContext(savedComputeContext)
    })[3]
    cat("Time to load and predict: ", time, "\n")
  }
  
  if ("TreeDepthEffect" %in% testsToRun) {
    formula = ArrDelay ~ CRSDepTime + DayOfWeek
    airlineColumnar <- RxSqlServerData(sqlQuery="select [ArrDelay],[CRSDepTime],[DayOfWeek] FROM airlineColumnar", connectionString = sqlConnString)
    cat("\nRunning TreeDepthEffect Test. No transformations. Using airlineColumnar table.", "\n")
    for(depth in c(1,2,4,8,16)) {
      cat("Tree Depth: ", depth, "\n")
      testResult <- runTest(resultDir, "rxDTree", formula = formula, dataSource = airlineColumnar, transformFunc = NULL, transformVars = NULL, runs=5, maxDepth=depth)
      cat("Average Time: ", testResult$avgTime, "\n")
      times <- processTimings(testResult)
      if (printTimeSplits) {
        print(times)
      }
    }
  }

  if ("SaveLMModel" %in% testsToRun) {
    formula = ArrDelay ~ CRSDepTime + DayOfWeek
    # Train using first 9M rows. Predict using the last 1M rows.
    airline <- RxSqlServerData(sqlQuery="select [ArrDelay],[DayOfWeek], [CRSDepTime] FROM airlineWithIndex WHERE rowNum <= 9000000", connectionString = sqlConnString)
    cat("\nRunning SaveLMModel Test. Using airlineWithIndex table.", "\n")
    testResult <- runTest(resultDir, "lm", formula = formula, dataSource = airline, transformFunc = NULL, transformVars = NULL, runs=5)
    cat("Average Time: ", testResult$avgTime, "\n")
    times <- processTimings(testResult)
    if (printTimeSplits) {
      print(times)
    }
    odbcDS <- RxOdbcData(table = "rdata", connectionString = sqlConnString, useFastRead=TRUE)
    rxOpen(odbcDS, "w")
    rxExecuteSQLDDL(odbcDS, sSQLString = paste("delete from [rdata] where [key] = 'lm.model.1'", sep=""))
    rxClose(odbcDS)
    lmModel <- testResult$analyticsResult
    # lm model is quite big and contains data. So, we cannot store as it is in DB. We need to clean up unneeded fields.
    # It is the beyond the scope of this script to optimize the lm models. We will clean minimal information to get predict to work.
    m <- cleanupModel(lmModel)
    lmModel$fitted.values <- NULL
    lmModel$effects <- NULL
    lmModel$model <- NULL
    lmModel$residuals <- NULL
    time = system.time({
      dbSaveRDS(sqlConnString, "lm.model.1", m)
    })[3]
    cat ("Time to save model = ", time, "\n")
  }
  
  if ("LoadLMModelAndPredict" %in% testsToRun) {
    # This test demonstrats how we can load the saved model and do prediction. Here, we pull the data from SQL and predict.
    # See the script scoring.sql to see how TSQL can be used to predict using trivial parallelism.
    savedComputeContext <- rxGetComputeContext()
    rxSetComputeContext ("local")
    cat("\nRunning LoadLMModelAndPredict Test. 1M row prediction. Using airlineWithIndex table and local compute context.", "\n")
    time = system.time({
      mm <- dbReadRDS(sqlConnString, "lm.model.1")
      # Prepare the data for last 1M rows. Note that the
      airline <- RxSqlServerData(sqlQuery="select [ArrDelay],[DayOfWeek], [CRSDepTime] FROM airlineWithIndex WHERE rowNum > 9000000", connectionString = sqlConnString)
      df <- getDataFrameFromDataSource(airline, "airlineWithIndex") # coverts sql data into df by using RODBC.
      #df <- data.frame(DayOfWeek=factor(1, as.character(1:7)), CRSDepTime=9)
      pred <- predict(mm, df)
      rxSetComputeContext(savedComputeContext)
    })[3]
    cat("Time to load and predict: ", time, "\n")
  }

  if ("SaveGlmModel" %in% testsToRun) {
    formula = ArrDelay ~ CRSDepTime + DayOfWeek
    # Train using first 9M rows. Predict using the last 1M rows.
    airline <- RxSqlServerData(sqlQuery="select [ArrDelay],[DayOfWeek], [CRSDepTime] FROM airlineWithIndex WHERE rowNum <= 9000000", connectionString = sqlConnString)
    cat("\nRunning SaveGlmModel Test. Using airlineWithIndex table.", "\n")
    testResult <- runTest(resultDir, "glm", formula = formula, dataSource = airline, transformFunc = NULL, transformVars = NULL, runs=5)
    cat("Average Time: ", testResult$avgTime, "\n")
    times <- processTimings(testResult)
    if (printTimeSplits) {
      print(times)
    }
    odbcDS <- RxOdbcData(table = "rdata", connectionString = sqlConnString, useFastRead=TRUE)
    rxOpen(odbcDS, "w")
    rxExecuteSQLDDL(odbcDS, sSQLString = paste("delete from [rdata] where [key] = 'glm.model.1'", sep=""))
    rxClose(odbcDS)
    lmModel <- testResult$analyticsResult
    # lm model is quite big and contains data. So, we cannot store as it is in DB. We need to clean up unneeded fields.
    # It is the beyond the scope of this script to optimize the lm models. We will clean minimal information to get predict to work.
    m <- cleanupModel(lmModel)
    lmModel$fitted.values <- NULL
    lmModel$effects <- NULL
    lmModel$model <- NULL
    lmModel$residuals <- NULL
    time = system.time({
      dbSaveRDS(sqlConnString, "glm.model.1", m)
    })[3]
    cat ("Time to save model = ", time, "\n")
  }
  
  if ("LoadGlmModelAndPredict" %in% testsToRun) {
    savedComputeContext <- rxGetComputeContext()
    rxSetComputeContext ("local")
    cat("\nRunning LoadGlmModelAndPredict Test. 1M row prediction. Using airlineWithIndex table and local compute context.", "\n")
    time = system.time({
      mm <- dbReadRDS(sqlConnString, "glm.model.1")
      # Prepare the data for last 1M rows
      airline <- RxSqlServerData(sqlQuery="select [ArrDelay],[DayOfWeek], [CRSDepTime] FROM airlineWithIndex WHERE rowNum > 9000000", connectionString = sqlConnString)
      df <- getDataFrameFromDataSource(airline, "airlineWithIndex") # coverts sql data into df by using RODBC.
      #df <- data.frame(DayOfWeek=factor(1, as.character(1:7)), CRSDepTime=9)
      pred <- predict(mm, df)
      rxSetComputeContext(savedComputeContext)
    })[3]
    cat("Time to load and predict: ", time, "\n")
  }
}

####################################################################################################
# Set some global variables to simplify running the tests.
####################################################################################################
resultsFolderDir <- file.path(dir, "Results")
suppressWarnings(dir.create(resultsFolderDir))
airlineXdfFile <- file.path(dataDir, "Airline10M.xdf" )
airlineXdf <- RxXdfData(airlineXdfFile)

####################################################################################################
# Set some global flags to control what gets printed when running the tests.
####################################################################################################
printEachTestRuntime <- TRUE # Prints run time for each test
printTimeSplits <- FALSE # Print the time for IO/Transition/Compute.



####################################################################################################
# Set the global to contain all the tests to run.
####################################################################################################
testsToRun <- c("FactorCol", "IntCol", "NoCompression", "PageCompression", "RowCompression", "WithTransformation", 
                "WithoutTransformation", "RowStore", "ColStore", "CubeArgEffect", "SaveModel", "LoadModelAndPredict",
                "TreeDepthEffect", "SaveLMModel", "LoadLMModelAndPredict", "SaveGlmModel", "LoadGlmModelAndPredict")

cat("call runTests(testsToRun, 'Run1', 1, 500000L) to run tests.\n")
#runTests(testsToRun, "Run1", 1, 500000L)

# Start with local compute context. The test driver should restore to this context when it returns.
rxSetComputeContext ("local")


